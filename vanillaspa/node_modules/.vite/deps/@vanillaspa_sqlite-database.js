// node_modules/@vanillaspa/sqlite-database/index.js
import sqlite3InitModule from "@sqlite.org/sqlite-wasm";
var name = "sqlite";
var workers = {};
function initalizeWorker(name2) {
  let worker = new Worker(new URL("./sqliteWorker.js", import.meta.url), { type: "module" });
  if (workers[name2]) {
    console.error("InstantiationError: already taken");
    worker.terminate();
  } else {
    workers[name2] = worker;
  }
}
function createDB(name2 = "default") {
  return new Promise((resolve, reject) => {
    initalizeWorker(name2);
    let worker = getWorker(name2);
    worker.onmessage = function({ data }) {
      const { type, message } = data;
      if (type === "created") {
        resolve({ message });
      }
    };
    worker.onerror = (error) => {
      reject(new Error(error));
    };
    worker.postMessage({ action: "createDB", name: name2 });
  });
}
async function deleteAndTerminateDB(name2) {
  var root = await navigator.storage.getDirectory();
  let fileSystemFileHandle = await root.getFileHandle(`${name2}.sqlite3`);
  if (fileSystemFileHandle) {
    let worker = workers[name2];
    worker.onmessage = async function({ data }) {
      const { type } = data;
      if (type === "closed") {
        console.log("Removing...", fileSystemFileHandle);
        await fileSystemFileHandle.remove();
        await worker.terminate();
      }
      delete workers[name2];
    };
    worker.postMessage({ action: "closeDB" });
  }
}
function downloadDB(name2 = "default") {
  let worker = workers[name2];
  if (worker) {
    worker.onmessage = function({ data }) {
      const { type } = data;
      if (type === "application/vnd.sqlite3") {
        let downloadChannel = new BroadcastChannel("download_channel");
        downloadChannel.postMessage(data);
        downloadChannel.close();
      }
    };
    worker.postMessage({ action: "downloadDB" });
  }
}
function executeQuery(sql, name2 = "default") {
  return new Promise((resolve, reject) => {
    let worker = getWorker(name2);
    if (worker) {
      worker.onmessage = function({ data }) {
        const { type } = data;
        if (type === "application/json") {
          const { result } = data;
          resolve(result);
        }
      };
      worker.onerror = (error) => {
        reject(error);
      };
      worker.postMessage({ action: "executeQuery", sql });
    } else {
      reject(new Error("No worker"));
    }
  });
}
function executeStatement({ sql, values, name: name2 = "default" }) {
  return new Promise((resolve, reject) => {
    let worker = getWorker(name2);
    if (worker) {
      worker.onmessage = function({ data }) {
        const { type } = data;
        if (type === "application/json") {
          const { result } = data;
          resolve(result);
        }
      };
      worker.onerror = (error) => {
        reject(error);
      };
      worker.postMessage({ action: "prepareStatement", sql, values });
    } else {
      reject(new Error("No worker"));
    }
  });
}
function getWorker(name2 = "default") {
  let worker = workers[name2];
  return worker ? worker : void 0;
}
function getWorkers() {
  return workers;
}
function uploadDB(fileName, arrayBuffer) {
  let [name2, extension] = fileName.split(".");
  if (["sqlite", "sqlite3"].includes(extension)) {
    let worker = workers[name2];
    if (!worker) {
      initalizeWorker(name2);
      worker = getWorker(name2);
      console.log({ worker });
    }
    worker.postMessage({ action: "uploadDB", name: name2, arrayBuffer });
  } else {
    throw new Error({ name: "UnsupportedError", message: "Unsupported extension" });
  }
}
function terminate(name2 = "default") {
  let worker = workers[name2];
  if (worker) {
    worker.postMessage({ command: "terminate" });
  }
}
if (window.Worker) {
  try {
    const sqlite3 = await sqlite3InitModule({ print: console.log, printErr: console.error });
    console.log("Running SQLite3 version", sqlite3.version.libVersion);
  } catch (err) {
    console.error("Initialization error:", err.name, err.message);
  }
} else {
  console.error("Your browser doesn't support web workers.");
}
export {
  createDB,
  deleteAndTerminateDB,
  downloadDB,
  executeQuery,
  executeStatement,
  getWorker,
  getWorkers,
  name,
  terminate,
  uploadDB
};
//# sourceMappingURL=@vanillaspa_sqlite-database.js.map
